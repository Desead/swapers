# i18n.md — Многоязычность сайта (Django)

Этот файл — краткая, но полноценная инструкция по тому, как устроена и поддерживается многоязычность на проекте: URL-префиксы, разметка переводов в шаблонах и Python-коде, сбор переводов и работа с Poedit.

---

## 1) Общая идея и URL-префиксы

* Все локализуемые страницы отдаются **с языковым префиксом**: `/ru/...`, `/en/...`.
* Префиксы добавляются через `i18n_patterns(...)` в `urls.py`.
  Пример (минимально необходимое):

  ```python
  # urls.py
  from django.urls import path, include
  from django.conf.urls.i18n import i18n_patterns
  from app_main import views

  urlpatterns = [
      path("i18n/", include("django.conf.urls.i18n")),  # POST /i18n/setlang — стандартный переключатель языка
  ]

  urlpatterns += i18n_patterns(
      path("", views.home, name="home"),
      # path("about/", views.about, name="about"),
      # ...
      # Если не хотите префикс для языка по умолчанию — явно задайте:
      # prefix_default_language=False,
  )
  ```
* **Когда использовать префикс вручную?** Почти никогда. Используй `reverse()` / `{% url %}` — Django сам подставит правильный `/<lang>/`.
* **Как менять язык?** Через стандартный `set_language` (форма/POST на `/i18n/setlang`), Django сохранит выбор в cookie `django_language` и/или в сессии.

---

## 2) Настройки (settings.py)

Минимальный набор:

```python
USE_I18N = True

LANGUAGE_CODE = "ru"  # язык по умолчанию
LANGUAGES = [
    ("ru", "Русский"),
    ("en", "English"),
]

LOCALE_PATHS = [BASE_DIR / "locale"]  # где лежат .po/.mo

MIDDLEWARE = [
    "django.middleware.security.SecurityMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "django.middleware.locale.LocaleMiddleware",  # <-- после Session, до Common
    "django.middleware.common.CommonMiddleware",
    # ...
]
```

---

## 3) Переводимый текст в **шаблонах**

Всегда подключай библиотеку i18n:

```django
{% load i18n %}
```

### Короткие строки

```django
<h1>{% trans "Личный кабинет" %}</h1>
```

### Строки с переменными

```django
{% blocktrans with email=request.user.email %}
Ваш email: {{ email }}
{% endblocktrans %}
```

### Множественное число

```django
{% blocktrans count count=items|length %}
У вас {{ count }} товар в корзине.
{% plural %}
У вас {{ count }} товара в корзине.
{% endblocktrans %}
```

### Контекст (разные значения одного слова)

```django
{% trans "May" context "month name" %}
```

### Советы

* Для длинных фрагментов и HTML используй `{% blocktrans trimmed %}`.
* **Не** вставляй теги внутрь переводимой строки вперемешку с текстом. Либо `blocktrans` и переменные, либо заверни теги вне блока.

---

## 4) Переводимый текст в **Python-коде**

Импорты:

```python
from django.utils.translation import gettext_lazy as _
from django.utils.translation import gettext, ngettext, pgettext
```

### Где какой использовать

* **`gettext_lazy as _`** — на уровне импорта/классов: `verbose_name`, `help_text`, метки форм, `choices`.
  Пример:

  ```python
  first_name = models.CharField(_("Имя"), max_length=150, blank=True)
  ```
* **`gettext()`** — в рантайме: исключения, `__str__`, сообщения пользователю, логи.

  ```python
  raise ValueError(gettext("Неверный код подтверждения"))
  ```
* **`ngettext()`** — множественное число в Python:

  ```python
  msg = ngettext("%(n)d файл загружен", "%(n)d файлов загружено", n) % {"n": n}
  ```
* **`pgettext()`** — когда одно и то же слово нужно различать по контексту:

  ```python
  title = pgettext("navbar", "Home")
  ```

### Интерполяция — только **именованными** плейсхолдерами

```python
gettext("Здравствуйте, %(name)s!") % {"name": user.first_name or ""}
```

Так переводчики видят структуру строки, а не «склеенный» f-string.

### Письма/таски вне запроса

Если тебе нужно временно принудить язык:

```python
from django.utils.translation import override

with override("en"):
    send_email(...)
```

---

## 5) Сбор переводов (.po/.mo)

Стандартная схема:

```bash
# Создать/обновить каталоги переводов
python manage.py makemessages -l ru -l de -l fr -l es -l it -l uk `
  --ignore=.venv/* --ignore=node_modules/* --no-location
# если есть переводы в JS:
python manage.py makemessages -d djangojs -l ru -l de -l fr -l es -l it -l uk `
  --ignore=.venv/* --ignore=node_modules/* --no-location

# Скомпилировать в .mo
django-admin compilemessages
```

Структура:

```
locale/
  ru/LC_MESSAGES/django.po
  en/LC_MESSAGES/django.po
```

---

## 6) Работа с **Poedit**

1. Открой `locale/<lang>/LC_MESSAGES/django.po` в Poedit.
2. В «Свойствах каталога» проверь:

   * Кодировка: **UTF-8**
   * Путь к исходникам (корень проекта)
   * Для русского правильные **Plural-Forms**:

     ```
     nplurals=3; plural=(n%10==1 && n%100!=11 ? 0
                        : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1
                        : 2);
     ```
3. Нажимай **Update from sources** (или запускай `makemessages`) — появятся новые msgid.
4. Переводи, **сохраняй** — Poedit может автоматически собрать `.mo`, но надёжнее дополнительно выполнить:

   ```bash
   django-admin compilemessages
   ```
5. Убирай пометку **fuzzy**, иначе строка может игнорироваться.

---

## 7) Sitemap (кратко про i18n)

* В `Sitemap` можно включить:

  ```python
  class StaticViewSitemap(Sitemap):
      i18n = True          # на каждый язык
      alternates = True    # <xhtml:link rel="alternate"...> (Django ≥ 4.1)
  ```
* Не хардкодь `/<lang>/` — используй `reverse()`.

---

## 8) Чек-лист перед коммитом

* [ ] В шаблонах: `{% load i18n %}`, тексты — через `{% trans %}`/`{% blocktrans %}`.
* [ ] В моделях/формах/админке — `gettext_lazy` (`_`) для `verbose_name`, `help_text`, `choices`.
* [ ] В рантайме (ошибки, логи, письма) — `gettext`/`ngettext`.
* [ ] Все интерполяции — через `%(name)s` + словарь.
* [ ] `makemessages` → переводы в Poedit → `compilemessages`.
* [ ] Ссылки — через `reverse()`/`{% url %}` (без ручных `/<lang>/`).
* [ ] При необходимости — `override("xx")` вокруг фоновых задач/писем.

---

## 9) Частые ошибки и как их избежать

* **Жёстко прошитый `/ru/` или `/en/`** в ссылках → всегда `reverse()`/`{% url %}`.
* **f-strings в переводимых сообщениях** → используем плейсхолдеры `%(name)s`.
* **Смешивание HTML и текста внутри `{% trans %}`** → применяй `{% blocktrans %}` и переменные.
* **Ленивая функция не там** → `gettext_lazy` для атрибутов класса, `gettext` для кода во время выполнения.
* **Забыли скомпилировать .mo** → после правок в `.po` — обязательно `compilemessages`.

---

- http://127.0.0.1:8000/rosetta/ доступен только из ЛК и есть пользователь является персоналом, т.е. is_staff=True
- На Windows для makemessages/compilemessages нужны утилиты GNU gettext на PATH. Проще всего:

choco install gettext или scoop install gettext.
- 
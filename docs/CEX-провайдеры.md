# Документация для CEX-провайдеров

Ниже — общие правила и «контракт» тонких провайдеров (Bybit, KuCoin, HTX, WhiteBIT, MEXC) и базового конвейера. Это конспект того, как мы приводим ответы CEX к нашей единой модели `ExchangeAsset`.

---

## Термины

* **Тонкий провайдер** — файл `<provider>.py` с логикой запроса к API, разбором ответа и выдачей унифицированных строк (`ProviderRow`).
* **Базовый конвейер** — `UnifiedProviderBase`: принимает `ProviderRow`, классифицирует ассет, чистит/квантует значения, применяет правила и сохраняет в БД.
* **Тип ассета (`asset_kind`)** — одно из:

  * `CRYPTO`
  * `FIAT`
  * `NOTDEFINED` (не определён)
* **Флаги ввода/вывода**:

  * `AD`/`AW` — авто-ввод/авто-вывод (управляются провайдером+API).
  * `D`/`W` — ручной ввод/вывод (только для пользователя в админке; провайдер НЕ меняет на апдейтах).

---

## Поток данных

1. Провайдер делает запрос(ы) к API и собирает минимальный «нормализованный» набор полей в `ProviderRow` на **каждую монету/сеть**.
2. Базовый конвейер:

   * определяет тип ассета,
   * валидирует и нормализует числа (через `numeric`),
   * применяет централизованные правила,
   * пишет в БД/обновляет существующие записи,
   * ведёт статистику (`processed/created/updated/skipped` и т.д.).

---

## Контракт тонкого провайдера

### Что должен вернуть `iter_rows()`

На **каждую монету и сеть** — один `ProviderRow`:

* `asset_code` — тикер (верхним регистром).
* `asset_name` — display-имя (чистое).
* `chain_code` / `chain_name`:

  * **есть сеть** → `chain_code` непустой (все caps); `chain_name` — любой пригодный дисплей.
  * **нет сетей** → `chain_code=""` и `chain_name=""` (далее конвейер решит `FIAT`/`NOTDEFINED`).
* `AD` / `AW` — «как заявлено API» (без учёта подтверждений).
* `conf_dep` / `conf_wd` — подтверждения (см. правила ниже).
* Лимиты: `dep_min`, `dep_max`, `wd_min`, `wd_max`.
* Комиссии: `dep_fee_pct`, `dep_fee_fix`, `wd_fee_pct`, `wd_fee_fix`.
* `requires_memo` — признак мемо/тэга (по сети и нашим спискам).
* `amount_precision` — разумная точность для сумм.
* `is_stable` — признак стейблкоина (по `numeric.stable_set()`).
* `raw_meta` — **только корневой объект** монеты из ответа API (`json_safe`), без дублирования сетей/вложенных копий.

### Что НЕ делать в провайдерах

* НЕ трогать поля в долларах (`withdraw_min_usdt`, `withdraw_max_usdt`, `deposit_min_usdt`, `deposit_max_usdt`) — биржи почти не дают достоверных значений.
* НЕ писать/менять ручные флаги `D`/`W` на апдейтах. Для новых **FIAT** они ставятся `False` при создании автоматически (см. ниже).
* НЕ дублировать в `raw_meta` сетевые записи, цепочки `chain` и т.д. — храните только «root».

---

## Определение типа ассета

### 1) Есть сети ⇒ это **CRYPTO**

* Сам факт непустого `chain_code` означает крипто-актив.
* Наличие/отсутствие подтверждений влияет **только** на автофлаги (`AD`/`AW`), но **не** меняет тип.

### 2) Сетей нет ⇒ это либо **FIAT**, либо **NOTDEFINED**

Решает `numeric.infer_asset_kind(asset_code, chain_code, chain_name, fiat_codes=fiat_set())`:

* Если тикер входит в централизованный список фиата **или** есть явные фиат-подсказки (`BANK`, `SEPA`, `SWIFT`, `CARD` и т.п. в сети/имени) — **FIAT**.
* Иначе — **NOTDEFINED**.

#### Поведение флагов для безсетевых:

* **FIAT**: `AD=True`, `AW=True`. При **создании** записи ручные `D/W=False`. При апдейтах `D/W` не трогаем.
* **NOTDEFINED**: `AD=False`, `AW=False`. В БД будет «сеть» `NO_CHAIN` (`"NoChain"`).

---

## Подтверждения и автофлаги

* Подтверждения на **ввод** (`conf_dep`):

  * нет/пусто/0 → `AD=False`.
* Подтверждения на **вывод** (`conf_wd`):

  * нет/пусто/0 → `AW=False`.
* `ensure_wd_conf_ge_dep()` гарантирует монотонность: `conf_wd ≥ conf_dep` (если нужно).
* `AD` и `AW` независимы: может быть вывод доступен, а ввод — нет, и наоборот.

---

## Централизованные числовые правила (crypto)

Применяются для **крипты** (по всем провайдерам). Если запись нарушает правило — **пропускаем** её (не пишем в БД):

1. `withdraw_min` **> 0**
2. `withdraw_min` **≤ 100000**
3. `withdraw_fee_fixed` **≤ 100000**

*(Эти граничные условия лежат в `numeric` и используются провайдерами перед отдачей строки/в конвейере. Чёткие названия функций/констант — см. текущий `numeric.py`.)*

---

## Обработка комиссий и лимитов

* Все внешние числа загоняем через `numeric.D()` — он:

  * безопасно парсит строки/числа,
  * обнуляет мусор (NaN, пустые),
  * ограничивает экстремальные по модулю значения до безопасного конечного диапазона,
  * возвращает `Decimal`.
* Проценты — тоже через `D()` (а где нужно конвертировать долю → процент, делаем в провайдере конкретной биржи).
* Для MEXC мы **не пишем** `withdraw_max` вообще (слишком шумная метрика у них).

---

## Политики по провайдерам (точечные нюансы)

### Bybit

* Если у сети **нет ключа `withdrawFee`** — считаем, что вывод закрыт: `AW=False` (особенность API).
* Поле `withdrawPercentageFee` приходит **долей** (напр. `0.001`), конвертируем в проценты (`0.1%`).

### KuCoin

* Подтверждения:

  * депозит → `preConfirms` (если нет — 0),
  * вывод → `confirms` (если нет — берём `dep_conf`).
* Флаги из `isDepositEnabled`/`isWithdrawEnabled`.
* `chain_code` строим из `chainId`/`chainName`.

### HTX

* Если `chains` пусто → **NOTDEFINED** (без сетей крипты нет).
* При наличии сетей используем их подтверждения/флаги; нулевые подтверждения гасят только соответствующий автофлаг.

### WhiteBIT

* **Фиатный шлюз**: если у актива в `assets` есть `providers` **и** отсутствуют `confirmations` — считаем безсетевым фиатом (дальше общий конвейер классифицирует).
* Комиссии:

  * подтягиваем публичные и (если есть ключи) приватные,
  * **приватные** перекрывают публичные,
  * в `raw_meta` — только корневой объект `assets[<ticker>]`.

### MEXC

* Подпись: `/api/v3/capital/config/getall` (signed).
* Сетевые поля: `network`/`netWork`/`chain`; подтверждения `minConfirm` и отдельные для вывода `withdrawConfirm` могут отсутствовать (тогда используем `dep_conf`).
* Политика: **не пишем `withdraw_max`** (слишком шумная величина у них).

---

## Списки из `SiteSetup`

Получаем централизованно через `numeric`:

* `stable_set()` — множество тикеров стейблов (в верхнем регистре).
* `memo_required_set()` — множество сетей, где обязателен MEMO/TAG.
* `fiat_set()` — множество кодов фиата.

  > Для новых фиатных активов при создании запись появится, но **ручные** `D/W` будут `False` (включение — через админку).

---

## `raw_meta` — политика хранения

* Храним **только корневой объект** монеты, без дублирования под ключами `chain`, `networks` и т.п.
* Все `Decimal` внутри конвертируем в строки через `numeric.json_safe()` (рекурсивно).

---

## Ошибки и устойчивость

* Сетевые вызовы — с повторами и джиттером ожидания (тонкий провайдер).
* Любую некорректную сетевую строку пропускаем (не валим весь импорт).
* При невозможности подписать/нет ключей (для приватных частей) — работаем только с публичными данными; приватные комиссии опциональны.

---

## Тестирование

* Юнит-тесты провайдеров: подменяем `fetch_payload()` и возвращаем **список строк** (а не верхнеуровневый dict).
  Прогоним `sync_assets()` и проверим состояние БД (`ExchangeAsset`) и флаги.
* Тесты `numeric` — покрывают `D()`, `B()`, `disp()`, `json_safe()`, `infer_asset_kind()` и сбор списков из `SiteSetup` (через monkeypatch).

---

## Резюме правил (коротко)

1. **Есть сеть** → `CRYPTO`. Нет подтверждений — гасятся `AD`/`AW`, **тип не меняем**.
2. **Нет сетей** → `FIAT` (если в `fiat_set()`/по подсказкам) **или** `NOTDEFINED` (иначе).

   * FIAT: `AD=AW=True`, при **создании** `D=W=False`, на апдейтах `D/W` не трогаем.
   * NOTDEFINED: `AD=AW=False`, сеть — `NoChain`.
3. Централизованные крипто-фильтры: `withdraw_min > 0`, `withdraw_min ≤ 100000`, `withdraw_fee_fixed ≤ 100000`; нарушителей — **пропускаем**.
4. Все числа через `numeric.D()`; `raw_meta` — только root, с `json_safe()`.
5. Частные провайдерские нюансы (Bybit-fee, KuCoin-preConfirms, WhiteBIT-fiat/providers, MEXC-без withdraw_max, HTX-без сетей → NOTDEFINED) соблюдаем в тонких провайдерах.

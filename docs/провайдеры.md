# Документация по сборщикам и провайдерам (app_market)

Эта заметка объясняет, как устроена новая централизованная система провайдеров и сборщиков в `app_market`, как добавить новый провайдер, как запускать сбор монет/цен/статистики, где лежит код, какие настройки важны, и как быстро проверить, что всё работает.

---

## Архитектура: что к чему привязано

```
app_market/
  collectors/            # ЕДИНАЯ точка входа
    runner.py            # CLI-раннер: последовательный запуск задач по провайдерам
    tasks.py             # Три шага: run_wallet_assets / run_prices / run_stats
    dump.py              # Сырой дамп: logs/raw/<тип>-<провайдер>.json (один файл, без перезаписи)
    credentials.py       # Централизованный доступ к API-ключам (ExchangeApiKey)
    # (celery_tasks.py)  # Опционально: периодический запуск через Celery (позже)

  providers/             # Логика провайдеров (НЕ удаляем)
    base.py, http.py, numeric.py, ...
    cex/*.py             # Биржи (Bybit, Kucoin, Mexc, Htx, WhiteBit, Rapira...)
    cash/*.py            # Курсы фиата (TwelveData, OpenExchangeRates, ...)

  prices/                # Сбор L1-цен (НЕ удаляем)
    price_bybit.py, price_mexc.py, ...  # для каждого провайдера: collect_spot(exchange, dry_run=False)
    price_twelvedata.py, price_openexchangerates.py
    publisher.py         # publish_l1_code → Redis; при флаге admin_mirror дублируем в БД (PriceL1)

  services/
    stats.py             # Сбор статистики; может бросать StatsError, если не реализовано

  models/
    exchange.py          # Exchange + автоопределение kind; stablecoin=USD при создании для PSP/BANK/CASH
    price.py             # PriceL1 — витрина L1-цен для админки (без истории)

  admin/
    exchanges_admin.py   # Экшены в админке: синхронная загрузка монет + сбор статистики
```

---

## Настройки (dev.py)

Главное — **реестр провайдеров**. Это «источник правды» для раннера и админки:

```python
# swapers/settings/dev.py

COLLECTORS_PROVIDER_REGISTRY = {
    "BYBIT": {
        "path": "app_market.providers.cex.bybit:BybitAdapter",
        "enabled": True,
        "needs_api": True,   # если адаптер требует ExchangeApiKey
    },
    "MEXC": {
        "path": "app_market.providers.cex.mexc:MexcAdapter",
        "enabled": True,
        "needs_api": True,
    },
    "WHITEBIT": {
        "path": "app_market.providers.cex.whitebit:WhitebitAdapter",
        "enabled": True,
        "needs_api": True,
    },
    "HTX": {
        "path": "app_market.providers.cex.htx:HtxAdapter",
        "enabled": True,
        "needs_api": True,
    },
    "KUCOIN": {
        "path": "app_market.providers.cex.kucoin:KucoinAdapter",
        "enabled": True,
        "needs_api": True,
    },
    "RAPIRA": {
        "path": "app_market.providers.cex.rapira:RapiraAdapter",
        "enabled": True,
        "needs_api": False,
    },
    "TWELVEDATA": {
        "path": "app_market.providers.cash.twelvedata:TwelveDataCashAdapter",
        "enabled": True,
        "needs_api": False,
    },
    "OPENEXCHANGERATES": {
        "path": "app_market.providers.cash.openexchangerates:OpenExchangeRatesCashAdapter",
        "enabled": True,
        "needs_api": False,
    },
}

# Интервалы (используются позже в Celery, можно и раннером)
COLLECTORS_PRICES_INTERVAL_S = 10
COLLECTORS_WALLET_INTERVAL_S = 3600

# Куда кладём сырые дампы (по умолчанию BASE_DIR/logs/raw)
COLLECTORS_DUMP_ROOT = BASE_DIR / "logs" / "raw"
```

> Поле `path` — строка вида `"module.path:ClassName"`.
> `enabled=False` исключит провайдера из запусков.
> `needs_api=True` заставит раннер подхватить ключи через `collectors.credentials.get(...)`.

---

## Как устроены сборщики (collectors)

### `runner.py` — единый CLI

* Инициализирует Django (`DJANGO_SETTINGS_MODULE=swapers.settings.dev`).
* Читает `COLLECTORS_PROVIDER_REGISTRY`.
* Для каждого `enabled`-провайдера грузит адаптер по `path`, подтягивает креды (если надо), **и последовательно** гоняет выбранные шаги.

Команды (Ubuntu, Python 3):

```bash
# всё сразу, один раз, дампим сырые и зеркалим цены в админку
python3 -m app_market.collectors.runner --task all --once --dump-raw --admin-mirror -v

# только монеты по конкретному провайдеру
python3 -m app_market.collectors.runner --task wallet-assets --provider BYBIT --once -v

# только цены (L1) по всем
python3 -m app_market.collectors.runner --task prices --once --admin-mirror -v

# только статистика (не реализовано у части — аккуратно скипается)
python3 -m app_market.collectors.runner --task stats --once -v
```

Флаги:

* `--dump-raw` — сохранит **один** JSON на тип/провайдера в `logs/raw`, если файла ещё нет.
* `--admin-mirror` — L1-цены дополнительно пишутся в БД (`PriceL1`) для отображения в админке.

### `tasks.py` — шаги

* `run_wallet_assets(provider, adapter, dump_raw=False)`
  Вызывает `adapter.sync_assets(exchange=..., ...)`.
  Если `dump_raw=True`, предварительно пробует `adapter.fetch_payload(...)` и сохраняет результат в `logs/raw/wallet-<prov>.json`.

* `run_prices(provider, dump_raw=False, mirror_to_admin=False)`
  Находит соответствующую функцию `collect_spot` из `app_market/prices/price_<prov>.py` и запускает её.
  При `mirror_to_admin=True` оборачивает `publish_l1_code`, чтобы записи попали в `PriceL1`.
  При `dump_raw=True` кладёт нормализованный publish-батч + best-effort «сырые» источники в `logs/raw/prices-<prov>.json`.

* `run_stats(provider, dump_raw=False)`
  Вызывает `services.stats.collect_exchange_stats(exchange, timeout=...)`.
  Если у провайдера не реализовано — кидается `StatsError` → **мы мягко возвращаем `{"skipped": True}`**, ошибка не валит цикл.
  При `dump_raw=True` сохраняет снимок в `logs/raw/stats-<prov>.json`.

### `dump.py` — дампы

* Один файл на комбинацию `(тип, провайдер)`:

  * `logs/raw/wallet-BYBIT.json`
  * `logs/raw/prices-BYBIT.json`
  * `logs/raw/stats-BYBIT.json`
* Если файл уже существует — **не перезаписываем**.
* Сериализация с `default=str` — безопасно для `Decimal`, `datetime` и т.д.

### `credentials.py` — ключи

* Единое место для чтения API-ключей (модель `ExchangeApiKey`).
* В будущем сюда добавятся роли/права ключей — поэтому **не дублируем логику** в других местах.

---

## Модели и важные нюансы

* `Exchange`: при **создании** объекта и **пустом** `stablecoin`:

  * если `exchange_kind` ∈ {`PSP`, `BANK`, `CASH`} → `stablecoin="USD"`;
  * иначе — пусто.
* Автоопределение `exchange_kind` идёт от провайдера (`_auto_kind_from_provider()`).
* `PriceL1`: хранит «витрину» L1 без истории (история — в Redis). Используется админкой для просмотра текущих котировок. В моделях обновлены `CheckConstraint` на `condition=` (готово к Django 6+).

---

## Админка: ручные действия

В `admin/exchanges_admin.py` есть два важных экшена:

* **«Синхронизировать активы (загрузить монеты) сейчас»**
  Загружает адаптер по `COLLECTORS_PROVIDER_REGISTRY`, аккуратно вызывает `sync_assets` (с патчем логгера, чтобы не падать на `extra['created']`), считает сводку и сообщает результат. После успешной загрузки может триггерить первичную статистику (если предусмотрена).

* **«Собрать статистику сейчас»**
  Вызывает `collect_exchange_stats(...)` по выбранным `Exchange`. Если статистика не реализована — сообщает «пропуск» (мы ловим `StatsError` и не красним админку).

> Экшены **не** зависят от старых management-команд — всё работает через новую централизованную схему.

---

## Как добавить нового провайдера (чек-лист)

1. **Реализация адаптера**

   * Добавь файл в `app_market/providers/cex/<name>.py` (или `cash/<name>.py` для фиата).
   * Наследуйся от базового провайдера, реализуй:

     * `sync_assets(...)` (как у существующих бирж, обычно просто `super().sync_assets(...)` c нужными параметрами);
     * при необходимости — `fetch_payload(...)` (для дампов).
   * Если нужен приватный API — адаптер должен уметь принимать `credentials`.

2. **Сбор цен (L1)**

   * Создай `app_market/prices/price_<name>.py` с функцией:

     ```python
     def collect_spot(exchange, dry_run=False) -> tuple[int, int]:
         # публикация L1 через publisher.publish_l1_code(...)
         return pushed_count, skipped_count
     ```
   * Не забудь `publisher.publish_l1_code(...)` — это гарантированная точка выхода (Redis +, при `admin_mirror`, дубль в БД).

3. **Статистика (опционально)**

   * Добавь ветку в `services/stats.py` (или отдельный модуль `stat_<name>.py`, если так принято у тебя) и подключи её в делегатор.
   * Пока не реализовано — **нормально**: `run_stats()` пропустит провайдера с понятным сообщением.

4. **Добавь провайдера в настройки**

   * В `dev.py` (и `prod.py`) в `COLLECTORS_PROVIDER_REGISTRY` добавь:

     ```python
     "MYEX": {
         "path": "app_market.providers.cex.myex:MyExAdapter",
         "enabled": True,
         "needs_api": True,  # если нужны приватные ключи
     }
     ```
   * Проверь, что `path` указывает на существующий класс, и что для `cash`-источников указана папка `providers.cash`, а не `providers.cex`.

5. **Создай Exchange**

   * Через админку или фикстуры добавь запись `Exchange(provider="MYEX")`.
   * `exchange_kind` определится автоматически. При необходимости исправь в админке.
   * Если `needs_api=True` — добавь `ExchangeApiKey` и привяжи к `Exchange`.

6. **Прогон локально**

   * Монеты:

     ```bash
     python3 -m app_market.collectors.runner --task wallet-assets --provider MYEX --once -v
     ```
   * Цены (с зеркалом в админку):

     ```bash
     python3 -m app_market.collectors.runner --task prices --provider MYEX --once --admin-mirror -v
     ```
   * Статистика (если есть):

     ```bash
     python3 -m app_market.collectors.runner --task stats --provider MYEX --once -v
     ```
   * Проверка дампов: `logs/raw/` появятся `wallet-myex.json`, `prices-myex.json`, `stats-myex.json` (если просил `--dump-raw` и файла ещё не было).

7. **Проверка в админке**

   * В карточке `Exchange` доступны экшены «Синхронизировать активы…» и «Собрать статистику…».
   * Цены смотри в разделе `PriceL1` (если запускал с `--admin-mirror`).

8. **Тесты** (минимум)

   * Добавь smoke-тест на `collect_spot` (без сети, с заглушкой публикации).
   * Допиши кейс на `run_wallet_assets` (с фиктивным `sync_assets`).
   * Если статистика реализована — тест на положительный путь.

---

## Как проверить доступность провайдера

Минимальный «хелсчек» до появления отдельной таски:

1. Импорт класса:

```bash
python3 - <<'PY'
import importlib
module, cls = "app_market.providers.cex.bybit", "BybitAdapter"  # замени на своего
m = importlib.import_module(module); A = getattr(m, cls)
print("OK:", A)
PY
```

2. Ключи (если `needs_api=True`): проверь, что в админке существует `ExchangeApiKey` у нужного `Exchange`.

3. Пробный сбор монет:

```bash
python3 -m app_market.collectors.runner --task wallet-assets --provider MYEX --once -v
```

— успешный `sync_done` в логе + запись в БД — значит, адаптер и сеть доступны.

4. Пробный сбор цен с зеркалом:

```bash
python3 -m app_market.collectors.runner --task prices --provider MYEX --once --admin-mirror -v
```

— проверь, что появились строки в `PriceL1` для твоего `Exchange`.

---

## Часто задаваемые вопросы

* **Почему дамп не обновляется?**
  По дизайну — **один** файл на провайдера/тип. Если файл есть, второй раз не пишет. Удали файл вручную и перезапусти шаг, если нужен новый снимок.

* **Почему статистика для некоторых провайдеров «пропущена»?**
  Значит, `services.stats` ещё не реализована для них (кидается `StatsError`). Это нормальный и учтённый сценарий.

* **Где включить/отключить провайдера?**
  Только в `COLLECTORS_PROVIDER_REGISTRY` (`enabled=True/False`). Никаких «скрытых мест» больше нет.

* **Зачем `--admin-mirror`?**
  Redis — источник истины для цен, но в админке удобно видеть снимок. Флаг временно дублирует публикацию в таблицу `PriceL1`.

---

Этого достаточно, чтобы новый разработчик за час разобрался, куда смотреть, как добавить провайдера и как запускать сбор. Если нужно — подготовлю версию в формате `README.md` для репозитория и/или отдельную страницу для Wiki проекта.

Вот удобная «шпаргалка» в формате README.md для твоего репозитория. Можешь положить в `docs/monitorings.md` или в корень как `MONITORINGS.md`.

---

# Партнёрские мониторинги: баннеры на главной и редирект `/go/monitoring/<id>/`

## Зачем это нужно

* Показываем на главной странице баннеры партнёрских мониторингов.
* Клики по баннерам идут **через наш контролируемый редирект**, где можно:

  * зафиксировать факт клика (время, IP, User-Agent, Referer, язык интерфейса);
  * при необходимости добавить антифрод-проверки/троттлинг/AB-метки;
  * затем отправить пользователя 302-редиректом на партнёрскую ссылку.

## Что реализовано

1. **Модели**

   * `app_library.BannerAsset` — библиотека файлов баннеров (поддержка PNG/JPG/GIF/SVG, контроль размера, тема `dark|light`).
   * `app_main.Monitoring` — партнёрский сервис:

     * `name`, `link`, `number`, `is_active`, `title` (подсказка при наведении);
     * `banner_light_asset` и/или `banner_dark_asset` (выбор из библиотеки);
     * геттеры `banner_light_url` / `banner_dark_url` для шаблона.

2. **Отображение на главной (`home.html`)**

   * Баннеры показываются только для `is_active=True`.
   * Порядок: сначала «BestChange» (без учёта регистра в названии), затем по `number` и `id`.
   * Если у мониторинга есть оба баннера (light/dark) — выводятся оба, иначе один.
   * ALT = `name`, TITLE = `title` (если задан).
   * Верстка без inline-JS, размеры баннера ограничены контейнером **max 88×31** (с сохранением пропорций), вывод в строку с переносами.

3. **Редирект и учёт кликов**

   * URL-паттерн: `name="monitoring_go"`, путь вида:
     `/go/monitoring/<id>/` (с учётом префикса языка из `i18n_patterns`, например: `/ru/go/monitoring/1/`).
   * Вьюха:

     * ищет `Monitoring` по `id`;
     * если `link` пустой — отдаёт **204 No Content** (ничего не делаем, но и не падаем);
     * фиксирует метаданные клика (IP, UA, Referer, язык, timestamp);
     * делает **302 Found** на `link`.

> Примечание: где именно сохраняются метаданные клика — смотрите реализацию `monitoring_go` в `app_main/views.py` (можно логировать в БД или в логгер; текущая реализация уже учитывает это).

---

## Как пользоваться (для администраторов)

1. **Загрузить баннеры в библиотеку**

   * Админка → «Библиотека баннеров» (`BannerAsset`).
   * Загрузите файл баннера, выберите «Тема» (`Светлый`/`Тёмный`).
   * Ограничение размера файла уже настроено (для защиты от «тяжёлых» загрузок).

2. **Создать/отредактировать мониторинг**

   * Админка → «Мониторинги» (`Monitoring`).
   * Заполните:

     * **Название** (`name`) — попадёт в ALT и ARIA-label.
     * **Ссылка** (`link`) — партнёрский URL.
     * **Место на сайте** (`number`) — чем меньше, тем выше; «BestChange» всегда будет первым вне зависимости от `number`.
     * **Включён** (`is_active`) — только включённые попадают на главную.
     * **Подсказка** (`title`) — показывается при наведении на баннер.
     * **Баннеры** — выберите из библиотеки светлый/тёмный (можно один из них).

3. **Проверить на сайте**

   * Откройте главную (`/` → редирект на `/<lang>/`), внизу страницы увидите ряд баннеров.
   * Клик по баннеру идёт через `/go/monitoring/<id>/` и затем на внешнюю `link`.

---

## Как это работает в коде (быстрый обзор)

* **Выборка и сортировка** на главной:

  * Фильтруем `Monitoring.objects.filter(is_active=True)`.
  * Аннотируем флаг `is_best` по `name__icontains="bestchange"`.
  * Сортировка: `order_by("-is_best", "number", "id")`.
* **Шаблон `home.html`**:

  * Для каждого мониторинга выводится одна или две `<a class="partner-badge">…<img/></a>` с нужным URL:

    * `href` всегда указывает на `{% url 'monitoring_go' mon.id %}`.
    * `<img>` получает `alt="{{ mon.name }}"`, `title="{{ mon.title }}"` (если есть).
    * Для каждого изображения — контейнер с максимальными размерами **88×31** и адаптивной шириной.
* **Редирект `monitoring_go`**:

  * При пустой `link` — 204 (это важно для стабильности, если админ ещё не внёс ссылку).
  * При наличии `link` — 302 без лишних параметров (чтобы не повредить партнёрский трекинг).

---

## Тесты

Есть набор проверок (см. `app_main/tests/`), в частности:

* Рендер на главной:

  * BestChange всегда первый.
  * Фильтр по `is_active`.
  * Наличие одной/двух картинок в зависимости от заполненных ассетов.
  * Корректный `alt`/`title`, наличие обёртки-ссылки на `monitoring_go`.

* Редирект-вью:

  * Возврат **204**, если `link` пуст.
  * Возврат **302** на указанную `link` в обычном случае.
  * На главной у баннера ссылка именно на `monitoring_go`, а не на внешний URL.

**Запуск тестов**

```bash
pytest -q
```

---

## Безопасность и качество

* **Open-redirect защита**: редирект идёт строго на `Monitoring.link` из нашей БД, мы не проксируем произвольные URL из запроса.
* **CSP-совместимость**: нет inline-обработчиков, стили оформлены безопасно (с nonce).
* **Доступность (a11y)**: ALT = название, ссылка содержит `aria-label` с именем мониторинга.
* **Производительность**: выборка компактная, сортировка по аннотации и индексируемым полям; изображения отдаются как есть, ограничение размеров выполняется стилями на клиенте.

---

## Типичные вопросы

**Почему «BestChange» всегда первый?**
Так проще поддерживать узнаваемый приоритет. Реализовано через аннотацию `is_best` и сортировку `-is_best`.

**Что будет, если у мониторинга нет баннера?**
Такой мониторинг не выводится на главной (верстка и тесты это учитывают).

**Что будет, если у мониторинга пустая `link`?**
Редирект-вью вернёт **204 No Content** (ничего не сломается, пользователь останется на странице).

**Где посмотреть логи кликов?**
Смотри реализацию `monitoring_go` в `app_main/views.py`. Сейчас уже пишем метаданные (время, IP, UA, Referer, язык); при необходимости их можно направить в БД или в отдельный логгер, либо отправлять в аналитическую систему.

---

## Что можно улучшить потом

* Добавить агрегированные метрики кликов по мониторингам (в админке и/или Grafana/Metabase).
* Троттлинг/квоты/защиту от ботов на уровне редирект-вью.
* Поддержку UTM-меток (опционально) и постбеков для продвинутой аналитики.

---

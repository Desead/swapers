Вот удобная «шпаргалка» в формате README.md для твоего репозитория. Можешь положить в `docs/monitorings.md` или в корень как `MONITORINGS.md`.

---

# Партнёрские мониторинги: баннеры на главной и редирект `/go/monitoring/<id>/`

## Зачем это нужно

* Показываем на главной странице баннеры партнёрских мониторингов.
* Клики по баннерам идут **через наш контролируемый редирект**, где можно:

  * зафиксировать факт клика (время, IP, User-Agent, Referer, язык интерфейса);
  * при необходимости добавить антифрод-проверки/троттлинг/AB-метки;
  * затем отправить пользователя 302-редиректом на партнёрскую ссылку.

## Что реализовано

1. **Модели**

   * `app_library.BannerAsset` — библиотека файлов баннеров (поддержка PNG/JPG/GIF/SVG, контроль размера, тема `dark|light`).
   * `app_main.Monitoring` — партнёрский сервис:

     * `name`, `link`, `number`, `is_active`, `title` (подсказка при наведении);
     * `banner_light_asset` и/или `banner_dark_asset` (выбор из библиотеки);
     * геттеры `banner_light_url` / `banner_dark_url` для шаблона.

2. **Отображение на главной (`home.html`)**

   * Баннеры показываются только для `is_active=True`.
   * Порядок: сначала «BestChange» (без учёта регистра в названии), затем по `number` и `id`.
   * Если у мониторинга есть оба баннера (light/dark) — выводятся оба, иначе один.
   * ALT = `name`, TITLE = `title` (если задан).
   * Верстка без inline-JS, размеры баннера ограничены контейнером **max 88×31** (с сохранением пропорций), вывод в строку с переносами.

3. **Редирект и учёт кликов**

   * URL-паттерн: `name="monitoring_go"`, путь вида:
     `/go/monitoring/<id>/` (с учётом префикса языка из `i18n_patterns`, например: `/ru/go/monitoring/1/`).
   * Вьюха:

     * ищет `Monitoring` по `id`;
     * если `link` пустой — отдаёт **204 No Content** (ничего не делаем, но и не падаем);
     * фиксирует метаданные клика (IP, UA, Referer, язык, timestamp);
     * делает **302 Found** на `link`.

> Примечание: где именно сохраняются метаданные клика — смотрите реализацию `monitoring_go` в `app_main/views.py` (можно логировать в БД или в логгер; текущая реализация уже учитывает это).

---

## Как пользоваться (для администраторов)

1. **Загрузить баннеры в библиотеку**

   * Админка → «Библиотека баннеров» (`BannerAsset`).
   * Загрузите файл баннера, выберите «Тема» (`Светлый`/`Тёмный`).
   * Ограничение размера файла уже настроено (для защиты от «тяжёлых» загрузок).

2. **Создать/отредактировать мониторинг**

   * Админка → «Мониторинги» (`Monitoring`).
   * Заполните:

     * **Название** (`name`) — попадёт в ALT и ARIA-label.
     * **Ссылка** (`link`) — партнёрский URL.
     * **Место на сайте** (`number`) — чем меньше, тем выше; «BestChange» всегда будет первым вне зависимости от `number`.
     * **Включён** (`is_active`) — только включённые попадают на главную.
     * **Подсказка** (`title`) — показывается при наведении на баннер.
     * **Баннеры** — выберите из библиотеки светлый/тёмный (можно один из них).

3. **Проверить на сайте**

   * Откройте главную (`/` → редирект на `/<lang>/`), внизу страницы увидите ряд баннеров.
   * Клик по баннеру идёт через `/go/monitoring/<id>/` и затем на внешнюю `link`.

---

## Как это работает в коде (быстрый обзор)

* **Выборка и сортировка** на главной:

  * Фильтруем `Monitoring.objects.filter(is_active=True)`.
  * Аннотируем флаг `is_best` по `name__icontains="bestchange"`.
  * Сортировка: `order_by("-is_best", "number", "id")`.
* **Шаблон `home.html`**:

  * Для каждого мониторинга выводится одна или две `<a class="partner-badge">…<img/></a>` с нужным URL:

    * `href` всегда указывает на `{% url 'monitoring_go' mon.id %}`.
    * `<img>` получает `alt="{{ mon.name }}"`, `title="{{ mon.title }}"` (если есть).
    * Для каждого изображения — контейнер с максимальными размерами **88×31** и адаптивной шириной.
* **Редирект `monitoring_go`**:

  * При пустой `link` — 204 (это важно для стабильности, если админ ещё не внёс ссылку).
  * При наличии `link` — 302 без лишних параметров (чтобы не повредить партнёрский трекинг).

---

## Тесты

Есть набор проверок (см. `app_main/tests/`), в частности:

* Рендер на главной:

  * BestChange всегда первый.
  * Фильтр по `is_active`.
  * Наличие одной/двух картинок в зависимости от заполненных ассетов.
  * Корректный `alt`/`title`, наличие обёртки-ссылки на `monitoring_go`.

* Редирект-вью:

  * Возврат **204**, если `link` пуст.
  * Возврат **302** на указанную `link` в обычном случае.
  * На главной у баннера ссылка именно на `monitoring_go`, а не на внешний URL.

**Запуск тестов**

```bash
pytest -q
```

---

## Безопасность и качество

* **Open-redirect защита**: редирект идёт строго на `Monitoring.link` из нашей БД, мы не проксируем произвольные URL из запроса.
* **CSP-совместимость**: нет inline-обработчиков, стили оформлены безопасно (с nonce).
* **Доступность (a11y)**: ALT = название, ссылка содержит `aria-label` с именем мониторинга.
* **Производительность**: выборка компактная, сортировка по аннотации и индексируемым полям; изображения отдаются как есть, ограничение размеров выполняется стилями на клиенте.

---

## Типичные вопросы

**Почему «BestChange» всегда первый?**
Это требование мониторинга. Реализовано через аннотацию `is_best` и сортировку `-is_best`.

**Что будет, если у мониторинга нет баннера?**
Такой мониторинг не выводится на главной (верстка и тесты это учитывают).

**Что будет, если у мониторинга пустая `link`?**
Редирект-вью вернёт **204 No Content** (ничего не сломается, пользователь останется на странице).

**Где посмотреть логи кликов?**
Смотри реализацию `monitoring_go` в `app_main/views.py`. Сейчас уже пишем метаданные (время, IP, UA, Referer, язык); при необходимости их можно направить в БД или в отдельный логгер, либо отправлять в аналитическую систему.

---

# Защита от ботов для переходов по партнёрским баннерам

## Что защищаем и зачем

Эндпоинт `GET /go/monitoring/<id>/` используется как «промежуточный» редирект на партнёрскую ссылку из модели `Monitoring`.
Задачи:

* не отдавать прямой редирект краулерам/ботам;
* не «скликивать» партнёрскую статистику;
* вести более чистый учёт кликов.

## Как это работает (коротко)

1. По `id` ищется активная запись `Monitoring (is_active=True)`. Если не найдена — 404.
2. Если у записи пустой `link` — ответ `204 No Content` (ничего отдавать).
3. Простейшая антибот-проверка:

   * должен быть **Referer** того же происхождения (same-origin) — тот же `scheme://host`, что и запрошенный сайт;
   * должен быть **User-Agent** (не пустой и не явно «ботоподобный» — базовая эвристика).
     Если проверка не пройдена — `204 No Content` без редиректа.
4. Если проверка пройдена:

   * фиксируем клик через `Monitoring.register_click()` (в нём вы можете логировать IP, User-Agent, Referer, язык, время; ошибки игнорируются, чтобы не мешать пользователю);
   * выполняем `302 Found` на партнёрский `link`. Если у ссылки нет схемы — принудительно добавляется `https://`.

## Возвращаемые коды

* **302** — обычный пользовательский клик с сайта (пройден антибот-гейт).
* **204** — у мониторинга нет ссылки **или** запрос выглядит как бот/прямой вызов (нет корректного Referer/UA).

## Что именно считается «похожим на человека»

Текущая лёгкая эвристика:

* Referer обязателен и **same-origin** с текущим сайтом (клики должны приходить со страниц сайта, а не «с воздуха»).
* User-Agent обязателен и не пустой.

> Условия максимально мягкие, но этого достаточно, чтобы отсечь большинство технических запросов (линтеры, сканеры, прямые GET из скриптов).

## Логирование

В `Monitoring.register_click()` рекомендуется сохранять минимум:

* время, IP (`X-Forwarded-For` → `REMOTE_ADDR`), User-Agent, Referer, язык запроса;
* `monitoring_id`/имя для связи.
  Храните агрегаты, а исходные логи — с разумным сроком ретенции (вопрос приватности/охраны ПДн).

## Взаимодействие с тестами

Так как защита требует заголовков, в тестах нужно передавать:

* `HTTP_REFERER="http://testserver/"` (same-origin);
* `HTTP_USER_AGENT="pytest-client"`.
  Именно так устроен вспомогательный `_get()` в тестах.

## Ограничения и нюансы

* Прямой заход пользователя по адресу `/go/monitoring/<id>/` в адресной строке **не** редиректит умышленно (не будет Referer) — такой вызов считается подозрительным.
* Если хотите поддержать прямые переходы в DEV/QA — можно временно ослабить гейт, например по флагу в настройках.

## Что можно усилить в будущем

* Пер-IP троттлинг (cache/Redis): «N кликов за M минут» на мониторинг/в целом.
* Блок-листы/аллоу-листы по User-Agent/ASN.
* Подпись ссылок (HMAC-токен с коротким TTL), чтобы редиректы принимались только с «наших» страниц.
* Отложенная запись кликов (очередь задач), чтобы исключить влияние БД на время ответа.

## Почему 302, а не 301

Используем **временный** редирект, чтобы иметь возможность менять партнёрские URL без долгих кешей на стороне клиентов/поисковиков.

---

Этого описания достаточно, чтобы понять логику, статусы, требования к заголовкам и как писать тесты/развивать защиту дальше.
